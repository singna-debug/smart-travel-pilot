import { NextRequest, NextResponse } from 'next/server';
import { generateTravelResponse } from '@/lib/ai-engine';
import { createKakaoTextResponse, createKakaoErrorResponse } from '@/lib/kakao-response';
import { KakaoSkillRequest } from '@/types';
import { messageStore } from '@/lib/message-store';

/**
 * ì¹´ì¹´ì˜¤ i ì˜¤í”ˆë¹Œë” ìŠ¤í‚¬ ì„œë²„ ì—”ë“œí¬ì¸íŠ¸
 */
import fs from 'fs';
import path from 'path';

// Logger helper
// Force absolute path for reliability
const log = (msg: string) => {
    console.log(msg);
};

/**
 * ì¹´ì¹´ì˜¤ i ì˜¤í”ˆë¹Œë” ìŠ¤í‚¬ ì„œë²„ ì—”ë“œí¬ì¸íŠ¸
 */
export async function POST(request: NextRequest) {
    const timestamp = new Date().toISOString();
    log(`[POST] ğŸš€ KAKAO REQUEST RECEIVED`);

    try {
        const rawBody = await request.text();
        if (!rawBody) {
            log('[POST] Empty body');
            return NextResponse.json(createKakaoErrorResponse('Empty body'));
        }

        const body: KakaoSkillRequest = JSON.parse(rawBody);
        const userMessage = body.userRequest?.utterance;
        const visitorId = body.userRequest?.user?.id || `kakao-${Date.now()}`;
        const nickname = body.userRequest?.user?.properties?.nickname;
        const callbackUrl = body.userRequest?.callbackUrl;

        log(`[POST] User: ${visitorId} (${nickname}), Msg: "${userMessage}", Callback: ${callbackUrl ? 'Yes' : 'No'}`);

        if (!userMessage) {
            log('[POST] No user message');
            return NextResponse.json(createKakaoErrorResponse('ë©”ì‹œì§€ë¥¼ ì¸ì‹í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'));
        }

        // ì½œë°± URLì´ ì œê³µëœ ê²½ìš° -> ë¬´ì¡°ê±´ ë¹„ë™ê¸° ì²˜ë¦¬ (íƒ€ì„ì•„ì›ƒ ë°©ì§€)
        if (callbackUrl) {
            log(`[POST] Async processing via callbackUrl`);

            // ë°±ê·¸ë¼ìš´ë“œ ì²˜ë¦¬ ì‹œì‘ (await í•˜ì§€ ì•ŠìŒ)
            processBackgroundTask(body, callbackUrl).catch(err => {
                log(`[Background Error] ${err.message}`);
                console.error('ë°±ê·¸ë¼ìš´ë“œ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', err);
            });

            // ì¦‰ì‹œ ì‘ë‹µ ë°˜í™˜ (useCallback: true)
            return NextResponse.json({
                version: "2.0",
                useCallback: true,
                data: {
                    text: "ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”! ë‹µë³€ì„ ì¤€ë¹„í•˜ê³  ìˆìŠµë‹ˆë‹¤. â³"
                }
            });
        }

        // ì½œë°± URLì´ ì—†ëŠ” ê²½ìš° (í…ŒìŠ¤íŠ¸ íˆ´ ë“±) -> ë™ê¸° ì²˜ë¦¬
        log(`[POST] Sync processing (no callbackUrl)`);
        const { message: responseMessage, consultationData } = await generateTravelResponse(
            visitorId,
            userMessage,
            nickname
        );

        consultationData.visitor_id = visitorId;

        // [Optimized] ì‘ë‹µ ì†ë„ ê°œì„ : ì‹œíŠ¸ ì €ì¥ì€ ë°±ê·¸ë¼ìš´ë“œë¡œ ë¯¸ë£¨ê³  ì‘ë‹µë¶€í„° ë³´ëƒ„
        const response = await createResponseData(visitorId, responseMessage, consultationData);

        // Fire-and-forget (await í•˜ì§€ ì•ŠìŒ)
        finalizeAssistantResponse(visitorId, responseMessage, consultationData, nickname).catch(e => {
            log(`[Background Finalize Error] ${e.message}`);
        });

        return NextResponse.json(response);

    } catch (error: any) {
        log(`[POST Error] ${error.message}`);
        console.error('ì¹´ì¹´ì˜¤ ìŠ¤í‚¬ API ì˜¤ë¥˜:', error);
        return NextResponse.json(createKakaoErrorResponse(`ì„œë²„ ì˜¤ë¥˜: ${error.message}`));
    }
}

/**
 * ë°±ê·¸ë¼ìš´ë“œ ì²˜ë¦¬ (Gemini ë° Google Sheets ì—°ë™)
 */
async function processBackgroundTask(body: KakaoSkillRequest, callbackUrl: string) {
    const visitorId = body.userRequest?.user?.id || `kakao-${Date.now()}`;
    const userMessage = body.userRequest?.utterance || '';
    const nickname = body.userRequest?.user?.properties?.nickname;

    log(`[Background] Start for ${visitorId}`);

    // 1. ì‚¬ìš©ì ë©”ì‹œì§€ ê¸°ë¡
    messageStore.addMessage(visitorId, 'user', userMessage);
    try {
        const { appendMessageToSheet } = await import('@/lib/google-sheets');
        appendMessageToSheet(visitorId, 'user', userMessage).catch(e => log(`[Sheet Log Error] ${e.message}`));
    } catch (e) { }

    // 2. AI ì‘ë‹µ ìƒì„±
    log(`[Background] Generating AI response...`);
    let responseMessage: string;
    let consultationData: any;

    try {
        const result = await generateTravelResponse(
            visitorId,
            userMessage,
            nickname
        );
        responseMessage = result.message;
        consultationData = result.consultationData;
        log(`[Background] AI Response generated. Length: ${responseMessage.length}`);
    } catch (aiError: any) {
        log(`[Background AI Error] ${aiError.message}`);
        throw aiError;
    }

    consultationData.visitor_id = visitorId;

    // 3. ì‘ë‹µ ë°ì´í„° ìƒì„±
    const responseBody = await createResponseData(visitorId, responseMessage, consultationData);

    // 4. ì½œë°± ì „ì†¡
    log(`[Background] Sending callback to: ${callbackUrl}`);
    try {
        const fetchResponse = await fetch(callbackUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(responseBody)
        });

        const responseText = await fetchResponse.text();
        log(`[Background] Callback status: ${fetchResponse.status}, Body: ${responseText.substring(0, 100)}`);
    } catch (error: any) {
        log(`[Background Callback Error] ${error.message}`);
    }

    // 5. ìµœì¢… ê¸°ë¡ ë° ì„¸ì…˜ ì—…ë°ì´íŠ¸
    log(`[Background] Finalizing response (Upserting sheet)...`);
    await finalizeAssistantResponse(visitorId, responseMessage, consultationData, nickname);
    log(`[Background] Done.`);
}

/**
 * ìµœì¢… ì‘ë‹µ ìƒì„± ë° ë°ì´í„° ê¸°ë¡ ê³µí†µ ë¡œì§
 */
async function finalizeAssistantResponse(visitorId: string, responseMessage: string, consultationData: any, nickname?: string) {
    const safeVisitorName = consultationData.customer.name !== 'ë¯¸ì •' ? consultationData.customer.name : (nickname || `ì†ë‹˜ ${visitorId.substring(0, 4)}`);

    // ì„¸ì…˜ ì—…ë°ì´íŠ¸
    messageStore.upsertSession(visitorId, {
        visitorName: safeVisitorName,
        visitorPhone: consultationData.customer.phone,
        destination: consultationData.trip.destination,
        productName: consultationData.trip.product_name,
        departureDate: consultationData.trip.departure_date,
        productUrl: consultationData.trip.url,
        status: consultationData.automation.status,
        automationDates: {
            balanceDueDate: consultationData.automation.balance_due_date,
            noticeDate: consultationData.automation.notice_date,
            nextFollowup: consultationData.automation.next_followup,
        },
    });

    // ì–´ì‹œìŠ¤í„´íŠ¸ ë©”ì‹œì§€ ì €ì¥
    messageStore.addMessage(visitorId, 'assistant', responseMessage);

    // ê¸°ë¡ ë¡œì§ (Sheets, Supabase)
    try {
        const { upsertConsultationToSheet, appendMessageToSheet } = await import('@/lib/google-sheets');

        // ì—…ì„œíŠ¸ ìˆ˜í–‰ (ë¹„ë™ê¸°ë¡œ ê²°ê³¼ ê¸°ë‹¤ë¦¼)
        log(`[Finalize] Upserting to sheet...`);
        const upsertResult = await upsertConsultationToSheet(consultationData);
        log(`[Finalize] Upsert result: ${upsertResult}`);

        await appendMessageToSheet(visitorId, 'assistant', responseMessage);

        if (process.env.NEXT_PUBLIC_SUPABASE_URL) {
            const { supabase } = await import('@/lib/supabase');
            if (supabase) {
                await supabase.from('consultations').upsert({
                    visitor_id: visitorId,
                    customer_name: safeVisitorName,
                    status: consultationData.automation.status,
                    summary: consultationData.summary
                }, { onConflict: 'visitor_id' });

                await supabase.from('message_logs').insert({
                    visitor_id: visitorId,
                    role: 'assistant',
                    content: responseMessage
                });
            }
        }
    } catch (e: any) {
        log(`[Finalize Error] ${e.message}`);
    }

    // return await createResponseData(visitorId, responseMessage, consultationData); // REMOVED
}

/**
 * ì‘ë‹µ ë°ì´í„° í¬ë§·íŒ…
 */
async function createResponseData(visitorId: string, responseMessage: string, consultationData: any) {
    // ë©”ì‹œì§€ ëì˜ ë¶ˆí•„ìš”í•œ ê³µë°±/ì¤„ë°”ê¿ˆ ê°•ë ¥ ì œê±°
    const trimmedMessage = responseMessage.replace(/\s+$/, '');

    // í€µì–´í”Œë¼ì´ ë²„íŠ¼ ì œê±° (í…ìŠ¤íŠ¸ë§Œ ì‘ë‹µ)
    const response = createKakaoTextResponse(trimmedMessage);
    if (response.template && response.template.quickReplies) {
        delete response.template.quickReplies;
    }
    return response;
}

export async function GET() {
    return NextResponse.json({
        status: 'ok',
        message: 'Smart Travel Pilot ì¹´ì¹´ì˜¤ ìŠ¤í‚¬ ì„œë²„ê°€ ì •ìƒ ì‘ë™ ì¤‘ì…ë‹ˆë‹¤.',
        timestamp: new Date().toISOString(),
    });
}
